#!/usr/bin/env python
# -*- coding: utf-8 -*-
#Author: Tim Henderson
#Email: tim.tadh@hackthology.com
#For licensing see the LICENSE file in the top level directory.

import os, sys
from getopt import getopt, GetoptError

import ast

VERSION = 'git master'

error_codes = {
    'usage':1,
    'file_not_found':2,
    'option':3,
    'args':4,
    'version':5,
    'bad_bool':6,
    'no_args':7,
    'bad_artspec':8,
    'bad_file_reads':9,
    'stdin_and_files':10,
    'file_instead_of_dir':11,
}

usage_message = \
'''usage: stat.py [Options] [FILE]+'''

extended_message = \
'''
Explanation

    Generates statistics on parse trees. "[FILE]+" is a list of files containing
    serialized parse trees. The format for the parse tree is a pre-order
    enumeration.

      grammar
       
        nodes := nodes node
        nodes := node
        node := NUM COLON STRING NEWLINE
        
        COLON = r':'
        NUM = r'[0-9]+'
        STRING = r'.+$'
        NEWLINE = "\\n"

        NB: Whitespace is signficant, but STRING matches whitespace (except for
            newline).
      
      eg.
        
        2:root
        2:left side
        0:x
        1:y
        0:z
        3:right side
        0:a
        0:b
        0:c

      corresponds to
                              root                                        
                              /  \                                        
                             /    \                                       
                    left side      right side                         
                    /    \         /    |    \                               
                   x      y       a     b     c                           
                          |                                               
                          z                                               
                                                                                  
Options

    -h, help                            print this message   
    -v, version                         print the version
    -g, grammar=<file>                  supply a known grammar to annotate
    -o, outdir=<directory>              supply a path to a non-existant
                                          directory
                                          [default: ./gramstats]
    -i, imgs=<bool>                     generate images
                                          [default: true]
    -t, tables=<bool>                   generate statistic tables (as csv files)
                                          [default: true]
    -a, artifacts                       list what artifacts `stat.py` can
                                          generate
    -A, artifact=<artspec>              generate a specific artifact only.
                                          Multiple '-A' flags allowed.
                                          [overrides -o,-i, and -t]
    -T, usetables=<directory>           look for pre-existing statistic tables
                                          in this directory. With this option
                                          no other files are required, however
                                          if more examples are given the tables
                                          are updated. The new tables will only
                                          overwrite the old tables if
                                          "-o <dirname>" == "-T <dirname>"
    -s, stdin                           accept ASTs on standard in. With blank
                                          lines seperating trees. If files are
                                          supplied with this flag it will be an
                                          error.

Specs

    <file>                              the path to a file
    <directory>                         the path to a directory.
    <bool>                              either "true" or "false"
    <artspec>                           <artifact>:<file>
    <artifact>                          an artifact in the list generated by
                                          --artifacts

'''


def log(msg):
    print msg

def version():
    '''Print version and exits'''
    log('stat.py version ' + VERSION)
    sys.exit(error_codes['version'])

def usage(code=None):
    '''Prints the usage and exits with an error code specified by code. If code
    is not given it exits with error_codes['usage']'''
    log(usage_message)
    if code is None:
        log(extended_message)
        code = error_codes['usage']
    sys.exit(code)

def mktree(s):
    '''Makes a tree from the pre-order enumeration. See the usage for the grammar.
    @params s : string in pre-order enumeration
    @returns <ast.Node> as the root of the tree.
    '''
    def g(s):
        for line in s.split('\n'):
            if not line: continue
            if ':' not in line:
                raise SyntaxError, 'Expected colon, none found.'
            children, sym = line.split(':', 1)
            if not children.isdigit():
                raise SyntaxError, ( 
                  'Expected the format to be children:label. Where children is '
                  'an int.'
                )
            yield int(children), sym
    return ast.build_tree(g(s))

def assert_file_exists(path):
    '''checks if the file exists. If it doesn't causes the program to exit.
    @param path : path to file
    @returns : the path to the file (an echo) [only on success]
    '''
    path = os.path.abspath(path)
    if not os.path.exists(path):
        log('No file found. "%(path)s"' % locals())
        usage(error_codes['file_not_found'])
    return path

def assert_dir_exists(path):
    '''checks if a directory exists. if not it creates it. if something exists
    and it is not a directory it exits with an error.
    '''
    path = os.path.abspath(path)
    if not os.path.exists(path):
        os.mkdir(path)
    elif not os.path.isdir(path):
        log('Expected a directory found a file. "%(path)s"' % locals())
        usage(error_codes['file_instead_of_dir'])
    return path

def read_file_or_die(path):
    '''Reads the file, if there is an error it kills the program.
    @param path : the path to the file
    @returns string : the contents of the file
    '''
    try:
        f = open(path, 'r')
        s = f.read()
        f.close()
    except Exception:
        log('Error reading file at "%s".' % path)
        usage(error_codes['bad_file_read'])
    return s

def split_stdin():
    '''Read the stdin a yield chunks seperated by the blank lines'''
    lines = list()
    for line in sys.stdin.read().split('\n'):
        if not line and lines:
            yield '\n'.join(lines)
            lines = list()
        elif line:
            lines.append(line)
    if lines:
        yield '\n'.join(lines)

def parse_bool(s):
    '''parses s to check it is in [true, false]. returns the appropriate
    bool. If it isn't a book prints error and exits.
    @param s : a string
    @returns bool
    '''
    bools = {'true':True, 'false':False}
    if s not in bools:
        log('Expected bool found "%s"' % (s))
        log('You probably want %s case matters' % str(bools.keys()))
        usage(error_codes['bad_bool'])
    return bools[s]

def artifacts(conf):
    '''Print the available artifacts and exit normally.'''
    log('No artifacts currently available.')
    sys.exit(0)

def parse_artspec(s):
    '''Parses "artspecs" and returns (artifact, outpath). An artspec is the
    just the name of the artifact colon the path where it should be placed.
    If string is not in the artspec langauge print error and exit.
    
      ie. name:path
      eg. asts:./gramstats/asts/
    
    @param s : string in outspec format
    @returns : artifact name, path
    '''
    if ':' not in s:
        log('Expecting an <artspec> got "%s"' % (s))
        usage(error_codes['bad_artspec'])
    name, path = s.split(':', 1)
    return name, path

def main(args):
    
    try:
        opts, args = getopt(args, 
            'hvg:o:i:t:aA:T:s', 
            [
              'help', 'version', 'grammar=', 'outdir=', 'imgs=', 'tables=',
              'artifacts', 'artifact=', 'usetables=', 'stdin',
            ]
        )
    except GetoptError, err:
        log(err)
        usage(error_codes['option'])
    
    stdin = False
    usetables = False
    outdir = './gramstats'
    grammar = None
    genimgs = True
    gentables = True
    requested_artifacts = dict()
    list_artifacts = False
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage()
        elif opt in ('-v', '--version'):
            version()
        elif opt in ('-g', '--grammar'):
            grammar = assert_file_exists(arg)
        elif opt in ('-o', '--outdir'):
            outdir = assert_file_exists(arg)
        elif opt in ('-i', '--imgs'):
            genimgs = parse_bool(arg)
        elif opt in ('-t', '--tables'):
            gentables = parse_bool(arg)
        elif opt in ('-a', '--artifacts'):
            list_artifacts = True
        elif opt in ('-A', '--Artifact'):
            requested_artifacts.update((parse_artspec(arg),))
        elif opt in ('-T', '--usetables'):
            usetables = assert_file_exists(arg)
        elif opt in ('-s', '--stdin'):
            stdin = True
    
    if len(args) > 0 and stdin:
        log('Cannot process both files and stdin, supply one or the other.')
        usage(error_codes['stdin_and_files'])

    if not ((len(args) != 0) or (usetables) or (stdin)):
        log('You must provide a list of syntax trees to characterize.')
        usage(error_codes['no_args'])

    file_paths = [assert_file_exists(arg) for arg in args]
    syntax_trees = [mktree(read_file_or_die(path)) for path in file_paths]
    if stdin: syntax_trees += [mktree(tree) for tree in split_stdin()]
    for tree in syntax_trees:
        print tree
        print
   
    if requested_artifacts:
        genimgs = False
        gentables = False

    conf = {'trees':syntax_trees,
            'grammar': '' if grammar is None else read_file_or_die(grammar),
            'outdir':assert_dir_exists(outdir),
            'readtables':usetables,
            'genimgs':genimgs,
            'gentables':gentables,
            'requested_artifacts':requested_artifacts,
    }
    
    if list_artifacts:
        artifacts(conf)
    print conf

if __name__ == '__main__':
    main(sys.argv[1:])

